<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[几谷 博客]]></title>
  <link href="http://blog.kayorl.com/atom.xml" rel="self"/>
  <link href="http://blog.kayorl.com/"/>
  <updated>2017-05-02T15:54:34+08:00</updated>
  <id>http://blog.kayorl.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[正确防御XSS 的姿势 - 读『白帽子讲 Web 安全』]]></title>
    <link href="http://blog.kayorl.com/xss-defence.html"/>
    <updated>2017-05-02T19:47:47+08:00</updated>
    <id>http://blog.kayorl.com/xss-defence.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<blockquote>
<p>HttpOnly</p>
</blockquote>

<p>禁止页面访问带有 HttpOnly 属性的 Cookie</p>

<blockquote>
<p>输入检查</p>
</blockquote>

<p>使特殊字符的攻击失效</p>

<blockquote>
<p>XSS Filter， 智能的输入检查</p>
</blockquote>

<p>检查是否包含了 <code>&lt;script&gt;</code> 、 <code>javascript</code> 等敏感字符</p>

<blockquote>
<p>输出检查</p>
</blockquote>

<p>变量在输出到 HTML 页面时，可以使用编码或转义的方式来防御</p>

<p>针对 HTML 代码的编码方式是 <code>HTMLEncode</code>，至少转义以下字符</p>

<pre><code>&amp; --&gt; &amp;amp;
&lt; --&gt; &amp;lt;
&gt; --&gt; &amp;gt;
&quot; --&gt; &amp;quot;
&#39; --&gt; &amp;#x27;
/ --&gt; &amp;#x2F;    //可能会闭合一些 HTML entity
</code></pre>

<p><code>JavaScriptEncode</code> 与 <code>HTMLEncode</code> 不一样，需要对 <code>\</code> 进行转义，而且，输出变量必须在引号内部，因为</p>

<pre><code class="language-js">
// 错误示范
var x = escapeJavaScript($evil);

// 正确示范
var y = &quot;&quot;+escapeJavaScript($evil);
</code></pre>

<p></br></p>

<h4 id="toc_0">防御！在 XSS 发生的地方终结它！</h4>

<blockquote>
<p>HTML 标签中输出</p>
</blockquote>

<pre><code>&lt;div&gt;&lt;sciprt&gt;alert(&quot;/xss/&quot;)&lt;/sciprt&gt;&lt;/div&gt;

&lt;a&gt;&lt;img src=# onerror=alert(1)/&gt;&lt;/a&gt;
</code></pre>

<p>对策：对变量使用 HtmlEncode</p>

<blockquote>
<p>HTML 属性中输出</p>
</blockquote>

<pre><code>&lt;div name=&quot;
    &quot;&lt;script&gt;alert(/xss/)&lt;/script&gt; &lt;&quot;
    &quot;&gt;&lt;/div&gt;
</code></pre>

<p>对策：对变量使用 HtmlEncode</p>

<blockquote>
<p>script 标签中输出</p>
</blockquote>

<pre><code class="language-js">var x = &quot;&quot;;alert(/xss/);//&quot;;
</code></pre>

<p>对策：对变量使用 JavaScriptEncode</p>

<blockquote>
<p>事件中输出</p>
</blockquote>

<pre><code>&lt;a href=# onclick=&quot;funcA(&#39;
    &#39;);alert(/xss);//
&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre>

<p>对策：对变量使用 JavaScriptEncode</p>

<blockquote>
<p>CSS 中输出</p>
</blockquote>

<pre><code class="language-css">background-image: url(&quot;javascript:alert(&#39;XSS&#39;)&quot;);
</code></pre>

<p>对策1：禁止用户变量在 style，html，css 文件中输出<br/>
对策2：使用 <code>encodeForCSS()</code></p>

<blockquote>
<p>地址中输出</p>
</blockquote>

<p>待续</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跨站脚本攻击(XSS) - 读『白帽子讲 Web 安全』]]></title>
    <link href="http://blog.kayorl.com/xss.html"/>
    <updated>2017-05-02T15:44:02+08:00</updated>
    <id>http://blog.kayorl.com/xss.html</id>
    <content type="html"><![CDATA[
<p>本名 CSS（Cross Site Script），因与层叠样式表（CSS，Cascade Style Sheet）名重，<br/>
无奈更名 XSS。</p>

<blockquote>
<p>定义：通过 <code>HTML 注入</code> 篡改网页，插入恶意脚本（XSS payload），控制用户浏览器</p>
</blockquote>

<span id="more"></span><!-- more -->

<p></br></p>

<h3 id="toc_0">XSS 类型</h3>

<blockquote>
<p>有不持久反射型 XSS</p>
</blockquote>

<p>将用户输入数据反射给浏览器，需要用户点击恶意链接</p>

<blockquote>
<p>也有持久的存储型 XSS</p>
</blockquote>

<p>恶意脚本保存到服务器端，（富文本）</p>

<blockquote>
<p>还有效果上是反射型 XSS 的DOM Based XSS</p>
</blockquote>

<p>修改页面的 DOM 节点</p>

<p></br></p>

<h3 id="toc_1">攻击开始 攻击1 - “Cookie” 劫持</h3>

<p>XSS 定义的图示法，画的颜色好像有点多 (⊙ˍ⊙)， 看大箭头<br/>
<img src="media/14937110420322/cookie%20%E5%8A%AB%E6%8C%81.png" alt="cookie 劫持"/></p>

<p>利用上面的原理图，用户点击 <code>link</code> 后，黑客可以盗取 <code>ok.com</code> 的 Cookie，拥有 cookie 之后就可以模拟用户操作了。</p>

<blockquote>
<p>解决方法：设置 Cookie 的 <code>“HttpOnly”</code> </p>
</blockquote>

<h4 id="toc_2">攻击2 - 构造 GET 和 POST 请求</h4>

<p>GET 请求的伪造：<br/>
假设 blog.com 存在 XSS 漏洞，可以插入一张图片，发起一个 get 的删除请求，看大箭头<br/>
<img src="media/14937110420322/get%20%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0.png" alt="get 请求伪造"/></p>

<p>POST 请求的伪造类似，不过不是插入图片。</p>

<ol>
<li>插入一个 form 元素，并调用<code>form.submit();</code>方法来自动提交。</li>
<li>还可以发送 ajax</li>
</ol>

<h4 id="toc_3">攻击3 - XSS 钓鱼</h4>

<p>前面脚本的攻击过程缺少 <code>与用户交互</code> 的过程，面对验证码和<code>old password</code>情况下失效，攻击事业难道就这么停止了吗？</p>

<p>不， 画出一个伪造登录框，在输入后，密码被发送到服务器上</p>

<p><img src="media/14937110420322/XSS%20%E9%92%93%E9%B1%BC.png" alt="XSS 钓鱼"/></p>

<h4 id="toc_4">攻击4 - 浏览器定向爆破，4，3，2，1</h4>

<p>检测浏览器版本（特定版本可能存在漏洞），如果浏览器刚好存在漏洞， OOps。。</p>

<h4 id="toc_5">攻击5 - 软件+浏览器，双重爆破</h4>

<p>通过判断用户安装的软件，选择对应的浏览器漏洞，植入木马</p>

<hr>

<p></br></p>

<h3 id="toc_6">XSS 构造技能入门, 字符编码</h3>

<p>“百度搜藏”的一个<code>&lt;script&gt;</code>输出一个变量，且该变量转移了双引号,即把<code>&quot;</code>转义成了 <code>\&quot;</code>;<br/>
GBK/GB2312编码下，  <code>%c1</code> 与 <code>\</code> 字符组合后会变成 Unicode 字符，<br/>
因次，利用这种转义,构造</p>

<pre><code>%c1&quot;;alert(/XSS/);//
</code></pre>

<p><img src="media/14937110420322/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%9E%84%E9%80%A0.png" alt="字符编码构造"/></p>

<h4 id="toc_7">法2 - 绕过长度限制</h4>

<ol>
<li>利用事件来缩短所需要的字节数</li>
<li> <code>location.hash</code> 不会随请求发送，那，把执行代码藏在这里吧。</li>
<li>利用注释符打通两个 input</li>
<li>利用<code>&lt;base&gt;</code>标签
5.<code>window.name</code>不受同源策略的限制，代码放在其中，新的域里只要执行<code>eval(name);</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全的原则 - 读『白帽子讲 Web 安全』]]></title>
    <link href="http://blog.kayorl.com/security-principle.html"/>
    <updated>2017-05-02T15:12:33+08:00</updated>
    <id>http://blog.kayorl.com/security-principle.html</id>
    <content type="html"><![CDATA[
<p>Secure By Default，<br/>
纵深防御，<br/>
数据与代码分离，<br/>
不可预见性</p>

<span id="more"></span><!-- more -->

<h4 id="toc_0">Secure By Default，安全总则</h4>

<blockquote>
<p>即白名单，黑名单的思想</p>
</blockquote>

<ul>
<li>网站服务器的 80 和 443 端口对外提供服务，其他端口屏蔽</li>
<li>网站的生产环境服务器上，列出软件清单，此清单外的软件禁止使用</li>
<li>用户提交富文本时，利用 XSS Filter 对用户的输入原文做 HTML parse，解析成标签对象后，再针对标签匹配 XSS 的规则</li>
<li>【黑】禁用 <code>&lt;script&gt;</code> <code>&lt;iframe&gt;</code> 标签</li>
</ul>

<blockquote>
<p>最小权限原则：不过度授权</p>
</blockquote>

<p>Linux 系统下， 使用普通账户登录，需要 root 权限操作时使用 sudo 完成</p>

<hr>

<h4 id="toc_1">纵深防御原则，看待问题</h4>

<blockquote>
<p>不同层面、角度对系统做出整体方案<br/>
在每个过程中设置有效的防御措施，都能导致入侵过程功亏一篑</p>
</blockquote>

<p>黑客：<br/>
低权限 webshell ---&gt; 上传文件 ---&gt; 提升权限为 root ---&gt; 渗透内网</p>

<blockquote>
<p>在正确的地方做正确的事情,<br/>
理解危险的本质，做出正确应对措施</p>
</blockquote>

<p>XSS 的防御技术发展过程: <br/>
过滤特殊符号 ---&gt; 区分富文本和非富文本 ---&gt; 对富文本做语法树分析 --&gt; 综合方案</p>

<hr>

<h4 id="toc_2">数据与代码分离原则, 漏洞成因</h4>

<blockquote>
<p>应用于因“注入”引发问题的场景</p>
</blockquote>

<p>缓存区溢出、XSS、SQL Injection、CRLF Injection、X-Path Injection等都是由于注入的问题</p>

<h4 id="toc_3">不可预见性原则，克服攻击方法</h4>

<blockquote>
<p>让攻击方法无效，也算成功防御</p>
</blockquote>

<ul>
<li>混淆文章 id</li>
<li>微软的 ASLR 技术，随机化进程的栈地址</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全的世界观 - 读『白帽子讲 Web 安全』]]></title>
    <link href="http://blog.kayorl.com/security-world.html"/>
    <updated>2017-05-02T14:25:51+08:00</updated>
    <id>http://blog.kayorl.com/security-world.html</id>
    <content type="html"><![CDATA[
<p>这学期上了华仔的『信息安全』，学会了内存溢出攻击，实现DES加密，自签数字证书（CA，邮件签名），理解 https/SSL 协议的信任问题，还有VPN的搭建。</p>

<blockquote>
<p>获益匪浅，谢谢华仔啦。(๑•̀ㅂ•́)و✧</p>
</blockquote>

<p>上周的阿里（投的前端岗）电话过来，被问及了关于浏览器安全方面的知识，以前对这方面印象模糊只知道大概，进不进得了阿里先不说，至少以后不要害人家公司嘛，因此，买书看书实战一番。</p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">安全的本质是信任</a>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<a href="#toc_1">信任域与信任边界</a>
</li>
<li>
<a href="#toc_2">信任条件的度需要把握</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_3">安全三要素：CIA</a>
</li>
</ul>


<h2 id="toc_0">安全的本质是信任</h2>

<blockquote>
<p>一切安全方案设计的基础，都是建立在信任关系上的，我们必须相信一些东西，一些基本的假设，安全方案才能建立；<br/>
否定一切，安全方法如无源之水，无法设计。</p>
</blockquote>

<p>如果 <u>信任基础</u> 被打破，那么设计的安全方案也就成了伪命题。</p>

<hr>

<h5 id="toc_1">信任域与信任边界</h5>

<blockquote>
<p>具有不同信任级别的区域称为信任域，划分信任域的边界称为信任边界。</p>
</blockquote>

<p>通过安全检查，可以将未知的人和物梳理开来。<br/>
需要安检: 数据(人) <em>----&gt;</em> 高等级的信任域(候机厅) <em>----&gt;</em> 低等级的信任域(公路)<br/>
不需安检: 数据(人) <em>----&gt;</em> 低等级的信任域(公路)   <em>----&gt;</em> 高等级的信任域(候机厅)</p>

<h5 id="toc_2">信任条件的度需要把握</h5>

<p>万事皆有可能，但对安全造成威胁的每个因素都考虑入内的话，成本过大。</p>

<blockquote>
<p>因此，要把握信任条件的度，使其恰到好处</p>
</blockquote>

<h2 id="toc_3">安全三要素：CIA</h2>

<blockquote>
<p>CIA: 机密性，完整性，可用性<br/>
CIA: Confidentiality，Integrity，Availability</p>
</blockquote>

<table>
<thead>
<tr>
<th>要素</th>
<th>描述</th>
<th>常见方法</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>机密性</td>
<td>数据内容不能泄露</td>
<td>加密</td>
<td>密码不能明文传输</td>
</tr>
<tr>
<td>完整性</td>
<td>数据内容完整，没有被篡改的</td>
<td>数字签名</td>
<td>胤禛改遗诏《传位十四子》</td>
</tr>
<tr>
<td>可用性</td>
<td>随需而得</td>
<td></td>
<td>Dos拒绝服务</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SOP 及其安全问题]]></title>
    <link href="http://blog.kayorl.com/same-origin-policy-and-security.html"/>
    <updated>2017-04-09T21:34:12+08:00</updated>
    <id>http://blog.kayorl.com/same-origin-policy-and-security.html</id>
    <content type="html"><![CDATA[
<p>浏览器的同源策略，限制了不同源的“document” 或脚本， 对当前 “document” 读取或设置某些属性</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">几种突破SOP 的方法</h3>

<h4 id="toc_1">jsonp, 兼顾老式浏览器</h4>

<blockquote>
<p>其他域加载代码,存在安全风险<br/>
知道请求是否失败不容易</p>
</blockquote>

<pre><code class="language-js">//我是 a 域
function dealJson(data) {
    //deal with json data
}

var script = document.createElement(&#39;script&#39;);
// 请求提供 json 数据的 b 域
script.src = &quot;http://www.b.com/jsonp?callback=dealJson&quot;;
document.body.insertBefore(script, document.body.firstChild);
</code></pre>

<pre><code class="language-js">// Match jsonp
var json = { &quot;success&quot;: true, &quot;data&quot;: &quot;secret&quot;};
return json;
</code></pre>

<hr>

<h4 id="toc_2">WebSocket</h4>

<p>首先,同源政策对 WebSocket 不适用<br/>
再移步 <a href="http://blog.csdn.net/frank_good/article/details/50856585">websocket 解释</a></p>

<hr>

<h4 id="toc_3">window.postMessage</h4>

<blockquote>
<p>H5 引入,允许跨窗口通信</p>
</blockquote>

<pre><code class="language-js">// 大家好, 我是 A 域
var popup = window.open(&#39;http://b.com&#39;, &#39;title&#39;);
popup.postMessage(&#39;Hello World!&#39;, &#39;http://b.com&#39;);
</code></pre>

<pre><code class="language-js">// 大家好, 我是 B 域, A 域是我的打开者
window.opener.postMessage(&#39;Nice to see you&#39;, &#39;http://aaa.com&#39;);
</code></pre>

<hr>

<h4 id="toc_4">window.name, 窗口载入的所有页面共享</h4>

<blockquote>
<p>每个页面对window.name都有读写的权限，不会因新页面的载入而进行重置。<br/>
简言之,这是窗口载入页面们的<code>window.name</code><br/>
小于 2M</p>
</blockquote>

<pre><code class="language-js">// 大家好,我是 a 域
var ifr = document.createElement(&#39;iframe&#39;);
ifr.display = none;
document.appendChild(ifr);

ifr.onload = function() {
    //这就是我想要的 字符串!!!
    var data= ifr.contentWindow.name;    
};
ifr.src = &#39;about:black&#39;;
</code></pre>

<pre><code class="language-js">// 大家好,我是 b 域
window.name = &quot;我是 a 梦寐以求的字符串&quot;
</code></pre>

<h4 id="toc_5">子域设置 document.domain ,通过内置 iframe 通信</h4>

<blockquote>
<p>只能将 domain 设置为更高一级,不能更低.</p>
</blockquote>

<pre><code class="language-js">// 我是 a 域, 我的域名被设置成一样的了
doucment.domain = &quot;kayorl.com&quot;;

var ifr = document.createElement(&#39;iframe&#39;);
ifr.display = none;
ifr.src = &#39;http://www.b.com&#39;;
document.appendChild(ifr);
ifr.onload = function() {
    var doc = ifr.concentDocument || ifr.contentWindow.document;
    // 操作 doc
    ifr.onload = null;
};
</code></pre>

<pre><code class="language-js">// 我是 b 域, 我的域名被设置成一样的了
document.domain = &quot;kayorl.com&quot;;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件处理 之 跨浏览器]]></title>
    <link href="http://blog.kayorl.com/event.html"/>
    <updated>2017-03-26T21:54:35+08:00</updated>
    <id>http://blog.kayorl.com/event.html</id>
    <content type="html"><![CDATA[
<p>由于各浏览器的事件对象存在差异,利用下面的 <code>EventUtil</code> 对象可以跨浏览器处理事件</p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">增减监听器</a>
</li>
<li>
<a href="#toc_1">获取 target 属性</a>
</li>
<li>
<a href="#toc_2">阻止系统默认行为</a>
</li>
<li>
<a href="#toc_3">获取事件</a>
</li>
<li>
<a href="#toc_4">停止事件在 DOM 层次中的传播</a>
</li>
<li>
<a href="#toc_5">修正鼠标按钮问题</a>
</li>
<li>
<a href="#toc_6">修正任意情况下滚轮的取值</a>
</li>
<li>
<a href="#toc_7">获取按键事件的字符编码</a>
</li>
</ul>


<h2 id="toc_0">增减监听器</h2>

<pre><code class="language-js">var EventUtil = {
    addHandler: function(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent(type, handler);
        } else {
            element[&quot;on&quot; + type] = handler;
        }
    },
    removeHandler: function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent(type, handler);
        } else {
            element[&quot;on&quot; + type] = null;
        }
    }
}
</code></pre>

<h2 id="toc_1">获取 target 属性</h2>

<pre><code class="language-js">var EventUtil = {
    
    ...
    /**
     * 使用 DOM0 级方法处理时, 事件处理的作用域是根据指定的方式确定的, 
                            this 不会始终等于事件目标,因而用 srcElement
     */  
    getTarget: function(event) {
        return event.target ? event.target : event.srcElement;
    }
}
</code></pre>

<h2 id="toc_2">阻止系统默认行为</h2>

<pre><code class="language-js">var EventUtil = {
    
    ...
    
    /**
     * 阻止默认行为,如点击链接时自动跳转
     * 使用 DOM0 级方法处理时, returnValue 属性相当于 preventDefault 方法
     */
    preventDefault: function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    }
}
</code></pre>

<h2 id="toc_3">获取事件</h2>

<pre><code class="language-js">var EventUtil = {
    
    ...
    
    /**
     * 使用 DOM0 级方法处理时, event 对象作为 window 对象的一个属性存在
     */
    getEvent: function(event) {
        return event ? event : window.event;
    },
  
}

</code></pre>

<h2 id="toc_4">停止事件在 DOM 层次中的传播</h2>

<pre><code class="language-js">var EventUtil = {
    
    ...
    
    /**
     * 立即停止事件在 DOM 层次中的传播
     * 使用 DOM0 级方法处理时, cancelBubble 属性相当于 stopPropagation 方法
     */
    stopPropagation: function(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    }
}

</code></pre>

<h2 id="toc_5">修正鼠标按钮问题</h2>

<pre><code class="language-js">var EventUtil= {
    
    ...
    
    /**
     * IE8 的问题........
     * 0 : 主按钮, 1 : 滚轮 , 2 : 次按钮
     */
    getButton: function(event) {
        if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) {
            return event.button;
        } else {
            switch (event.button) {
                case 0:
                case 1:
                case 3:
                case 5:
                case 7:
                    return 0;
                case 2:
                case 6:
                    return 2;
                case 4:
                    return 1;
            }
        }
    }
};
</code></pre>

<h2 id="toc_6">修正任意情况下滚轮的取值</h2>

<pre><code class="language-js">var EventUtil = {

    ...
    
    /**
     * 向前为加
     * opera 9.5 之前的版本中, wheelDelta 值正负号是颠倒的
     * FireFox 的滚轮信息保存在 detail 中,且值为 正常 wheelDelta 的 1 /40 
     */
    getWheelDelta: function(event) {
        if (event.wheelDelta) {
            return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta);
        } else {
            return -event.detail * 40;
        }
    }
};

/**
 * 修正任意情况下滚轮的取值
 */
(function() {
    function handleMouseWheel(event) {
        event.EventUtil.getEvent(event);
        var delta = EventUtil.getWheelDelta(event);
    }
    EventUtil.addHandler(document, &quot;mousewheel&quot;, handleMouseWheel);
    EventUtil.addHandler(document, &quot;DOMMouseScroll&quot;, handleMouseWheel);
})();
</code></pre>

<h2 id="toc_7">获取按键事件的字符编码</h2>

<pre><code class="language-js">var EventUtil = {
    
    ...
    
    /**
     * &lt;=IE8 及 opera 在 keyCode 中保存字符的 ASCII 编码
     */
    getCharCode: function(event) {
        if (typeof event.charCode == &quot;number&quot;) {
            return event.charCode;
        } else {
            return event.keyCode;
        }
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[外边距折叠]]></title>
    <link href="http://blog.kayorl.com/margin-collapse.html"/>
    <updated>2017-03-23T09:15:30+08:00</updated>
    <id>http://blog.kayorl.com/margin-collapse.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>毗邻的两个或多个外边距 (margin) 会合并成一个外边距。</p>
</blockquote>

<span id="more"></span><!-- more -->

<blockquote>
<p>参考 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Mastering_margin_collapsing</a><br/>
以及 w3help 的 <a href="http://www.w3help.org/zh-cn/kb/006/#header_3">CSS 框模型</a></p>
</blockquote>

<p>外边距毗邻,可以被归结为2点</p>

<ul>
<li>这两个或多个外边距没有被<code>非空内容</code>、<code>padding</code>、<code>border</code> 或 <code>clear</code> 分隔开。</li>
<li>margin 处于<code>普通流中</code></li>
</ul>

<h2 id="toc_0">两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠</h2>

<p><strong>两个或多个</strong><br/>
说明其数量必须是大于一个，又说明，折叠是元素与元素间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。</p>

<p><strong>毗邻</strong>,兄弟父子都可以毗邻<br/>
是指没有被非空内容、padding、border 或 clear 分隔开，说明其位置关系。</p>

<p>注意一点，在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； <u>只有在一个元素的 height 是 &quot;auto&quot; 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻</u>。</p>

<p><strong>垂直方向</strong><br/>
是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。</p>

<h2 id="toc_1">折叠后的 margin 的计算</h2>

<blockquote>
<p>MAX(正数) + MIN(负数) ,方向由符号决定</p>
</blockquote>

<ol>
<li>+20px, +10px , 取20px , 正向位移</li>
<li>-20px, -10px , 取-20px, 负向位移</li>
<li>+20px, -20px , -10px,  取 -20px + 20px = 0, 不位移</li>
</ol>

<blockquote>
<p>相邻 margin 要一起参与运算</p>
</blockquote>

<p>A 及 A 的父 , B 及 B 的父 , 都得参与运算,不能分别算完AB 的父元素之后再合并</p>

<pre><code>&lt;div style=&quot;margin:50px 0; background-color:green; width:50px;&quot;&gt;
    &lt;div style=&quot;margin:-60px 0;&quot;&gt;
           &lt;div style=&quot;margin:150px 0;&quot;&gt;A&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div style=&quot;margin:-100px 0; background-color:green; width:50px;&quot;&gt;
    &lt;div style=&quot;margin:-120px 0;&quot;&gt;
           &lt;div style=&quot;margin:200px 0;&quot;&gt;B&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h2 id="toc_2">不折叠与自身折叠</h2>

<ul>
<li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠</li>
<li>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠 ,如<code>overflow:hidden</code></li>
<li>元素自身的 margin-bottom 和 margin-top 相邻时也会折叠</li>
</ul>

<h2 id="toc_3">折叠反向</h2>

<p>在水平书写模式下，<code>margin</code> 折叠的是垂直方向，即 <code>margin-top/margin-bottom</code><br/>
在垂直书写模式下，<code>margin</code> 折叠的是水平方向，即 <code>margin-right/margin-left</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css 元素垂直、水平居中]]></title>
    <link href="http://blog.kayorl.com/css-centering.html"/>
    <updated>2017-03-22T20:42:56+08:00</updated>
    <id>http://blog.kayorl.com/css-centering.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">水平居中</h2>

<blockquote>
<p>inline-*</p>
</blockquote>

<pre><code>inline-* {
    text-align: center;
}
</code></pre>

<blockquote>
<p>已知高度的 block </p>
</blockquote>

<pre><code>block {
    margin: 0 auto; 
}
</code></pre>

<blockquote>
<p>未知高度的 block</p>
</blockquote>

<pre><code>block {
    display: inline-block;  
    text-align: center; 
}
</code></pre>

<h2 id="toc_1">垂直居中</h2>

<blockquote>
<p>inline 单行</p>
</blockquote>

<pre><code>inline-* {
    padding-top: 30px;   
    padding-bottom:30px; 
}
</code></pre>

<pre><code>inline-* {
    line-height: height;
    /* height 为元素高度 */
}
</code></pre>

<blockquote>
<p>inline 多行</p>
</blockquote>

<p>第一种方法,利用 <code>table</code> 标签</p>

<pre><code>table {
    ...
}
table tr td {
    /* the default value of vertical-align is middle */
}
</code></pre>

<p>第二种方法，模拟 <code>table</code>标签，为居中元素添加 <code>vertical-align</code>标签</p>

<pre><code>.parent { 
    display: table;
}

.child {
    display: table-cell;
    vertical-align: middle;
}
</code></pre>

<blockquote>
<p>已知高度的 block</p>
</blockquote>

<pre><code>.parent {
    position: relative;
}

.child {
    position: absolute;
    top:50%;
    margin-top: - height/2;
    /* 偏移是以块的左上角为锚的，以此需减去 block 高度的一半 */
}
</code></pre>

<blockquote>
<p>未知高度的 block</p>
</blockquote>

<pre><code>.parent {
    position: relative;
}

.child {
    position: absolute;
    top:50%;
    transform: translateY(50%);
}
</code></pre>

<blockquote>
<p>大招，flex</p>
</blockquote>

<pre><code>.parent {
    display: flex;
    flex-direction: column;
    justify-content: center;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css 命名约定]]></title>
    <link href="http://blog.kayorl.com/css-style.html"/>
    <updated>2017-03-22T14:24:54+08:00</updated>
    <id>http://blog.kayorl.com/css-style.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more --> 

<h2 id="toc_0">Object Oriented CSS (OOCSS)</h2>

<p>分离容器与内容</p>

<blockquote>
<p>别这么做啊！！！！</p>
</blockquote>

<pre><code>ul li.list-item {
    ...
}
</code></pre>

<blockquote>
<p>直接跳到元素</p>
</blockquote>

<pre><code>.list-item {
    ...
}
</code></pre>

<h2 id="toc_1"><del>Atomic CSS (ACSS)</del></h2>

<p>将每个元素拆分成原子</p>

<pre><code>.mt-20 {
    margin-top : 20px;
}

.fl {
    float : left;
}
</code></pre>

<h2 id="toc_2">Block, Element, Modifier (BEM)</h2>

<p>根据严规写出的，易于理解的 css 风格</p>

<pre><code>/* 块 */
.block {}

/* 块中元素，双下划线 */
.block__element {}

/* 元素或块的修改器，双连字符 */
.block--modifier {}
</code></pre>

<p>一个例子</p>

<pre><code>&lt;header class=&quot;col-header&quot;&gt;

    &lt;!-- 块元素 --&gt;
    &lt;h1 class=&quot;col-header__heading&quot;&gt;
        &lt;a class=&quot;col-header__link&quot; href=&quot;/&quot;&gt;clubmate.fi&lt;/a&gt;
    &lt;/h1&gt;

    &lt;!-- 块元素 --&gt;
    &lt;nav class=&quot;nav&quot;&gt;

        &lt;!-- 块元素 --&gt;
        &lt;a class=&quot;nav__item&quot; href=&quot;/&quot;&gt;Home&lt;/a&gt;

        &lt;!-- 元素与修改器 --&gt;
        &lt;a class=&quot;nav__item nav__item--uplink&quot; href=&quot;#header&quot;&gt;&amp;uarr;&lt;/a&gt;

    &lt;/nav&gt;
&lt;/header&gt;
</code></pre>

<hr/>

<p>BEM 是 OOCSS 的加强版，而且利于理解分辨，以后就采用这个啦~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动端适配开发要点]]></title>
    <link href="http://blog.kayorl.com/mobile-notice.html"/>
    <updated>2017-03-19T10:12:40+08:00</updated>
    <id>http://blog.kayorl.com/mobile-notice.html</id>
    <content type="html"><![CDATA[
<p>参考<br/><br/>
<code>Alloyteam</code>  团队的<a href="http://alloyteam.github.io/Spirit/modules/Standard/">移动开发规范概述</a><br/>
<code>贤心博客</code>的<a href="http://sentsin.com/web/54.html">手机/移动前端开发需要注意的20个要点</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">meta 标签设置</h2>

<pre><code>&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
</code></pre>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>值</th>
</tr>
</thead>

<tbody>
<tr>
<td>viewpoint</td>
<td>是否可以缩放Web页面</td>
<td>强制文档与设备的宽度保持1：1； 文档最大的宽度比列是1.0； user-scalable定义是否可缩放</td>
</tr>
<tr>
<td>apple-mobile-web-app-capable</td>
<td>iphone私有， 允许全屏模式浏览， 还可以添加至桌面</td>
<td> yes</td>
</tr>
<tr>
<td>apple-mobile-web-app-status-bar-style</td>
<td>iphone私有， safari顶端的状态条的样式</td>
<td>默认值为default（白色）， 可以设为black，black-translucent</td>
</tr>
<tr>
<td>format-detection</td>
<td>格式检测</td>
<td>默认全开启， telephone=yes email=yes address=yes(跳转到地图)</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">字体设置</h2>

<p>使用无衬线体<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>. <br/>
表单元素会被浏览器代理样式所覆盖，因此需让表单元素继承字体属性<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></p>

<pre><code>body {
    font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif;
}
input, label, select, option, textarea, button, fieldset, legend {
    font-family: inherit;
}
</code></pre>

<p>各操作系统所用字体如下</p>

<table>
<thead>
<tr>
<th>OS 版本</th>
<th style="text-align: center">语言</th>
<th style="text-align: center">字体</th>
</tr>
</thead>

<tbody>
<tr>
<td>&gt; iOS 4.0</td>
<td style="text-align: center">英文</td>
<td style="text-align: center">Helvetica Neue</td>
</tr>
<tr>
<td></td>
<td style="text-align: center">中文</td>
<td style="text-align: center">STHeiTi<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></td>
</tr>
<tr>
<td>&gt; Android 4.0</td>
<td style="text-align: center">中文/英文</td>
<td style="text-align: center">Roboto</td>
</tr>
<tr>
<td>&lt; iOS 4.0</td>
<td style="text-align: center">英文</td>
<td style="text-align: center">Helvetica</td>
</tr>
<tr>
<td>&lt; Android 4.0</td>
<td style="text-align: center">英文</td>
<td style="text-align: center">Droid Sans</td>
</tr>
<tr>
<td></td>
<td style="text-align: center">中文</td>
<td style="text-align: center">Droid Sans Fallback</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">基础交互</h2>

<p>设置全局的CSS样式，<br/>
避免图中的长按 <em>弹出菜单与选中文本</em> 的行为</p>

<pre><code>a, img {
    -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */
}
html, body {
    -webkit-user-select: none;   /* 禁止选中文本（如无文本选中需求，此为必选项） */
    user-select: none;
}
</code></pre>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>无衬线体（Sans-serif）专指西文中没有衬线的字体，与汉字字体中的黑体相对应。与衬线字体相反，该类字体通常是机械的和统一线条的，它们往往拥有相同的曲率，笔直的线条，锐利的转角。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p><img src="media/14898895604273/table-style-hover.png" alt="table-style-hove set-up" style="width:300px;"/>&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>华文黑体并不存在iOS的字体库中(<a href="http://support.apple.com/kb/HT5878)%EF%BC%8C">http://support.apple.com/kb/HT5878)，</a> 但系统会自动将华文黑体 <code>STHeiTi</code> 兼容命中系统默认中文字体<code>黑体-简</code>或<code>黑体-繁</code>&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[function 背后隐藏着什么秘密]]></title>
    <link href="http://blog.kayorl.com/function.html"/>
    <updated>2017-03-08T14:37:21+08:00</updated>
    <id>http://blog.kayorl.com/function.html</id>
    <content type="html"><![CDATA[
<p><del>恩，对象肯定是按引用传递的</del></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">所有函数的参数都是按值传递的，包括对象</h2>

<p>局部作用域中修改的 <strong>对象</strong> 会在全局作用域中体现出来, <u>并无法说明参数是按引用传递的</u>;</p>

<p>做一番假设：如果是按值传递的话，那么下面代码打印结果应该是 alien </p>

<pre><code class="language-js">function setName(obj){
    obj.name = &quot;cowboy&quot;; // 参数值被修改，原始引用不变
    obj= new Object();   // obj 被重写后引用的是局部对象了，并不是传入的 person
    obj.name = &quot;alien&quot;;
} // 执行完后的 obj 会被销毁

var person = new Object();
setName( person );
alert( person.name );    // &quot;cowboy&quot;
</code></pre>

<p>但实际结果是 cowboy，说明</p>

<blockquote>
<p>对象不是按引用传递的。</p>
</blockquote>

<h2 id="toc_1">函数内部对象及函数方法</h2>

<table>
<thead>
<tr>
<th style="text-align: center">类别</th>
<th style="text-align: center">名称</th>
<th style="text-align: center">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center"> 内部对象</td>
<td style="text-align: center">  arguments</td>
<td style="text-align: center">该对象有属性 callee 指向函数本身，<del>严格模式下调用 callee 会导致错误</del></td>
</tr>
<tr>
<td style="text-align: center"> 内部对象</td>
<td style="text-align: center">this</td>
<td style="text-align: center">指向环境对象</td>
</tr>
<tr>
<td style="text-align: center">属性</td>
<td style="text-align: center">length</td>
<td style="text-align: center"> 函数希望接收的命名参数的个数</td>
</tr>
<tr>
<td style="text-align: center">属性</td>
<td style="text-align: center"> prototype</td>
<td style="text-align: center">保存所有实例方法</td>
</tr>
<tr>
<td style="text-align: center">方法</td>
<td style="text-align: center"> <code>apply(scope, array)</code></td>
<td style="text-align: center">设置函数体内 this 对象的值，扩充函数运行的作用域</td>
</tr>
<tr>
<td style="text-align: center">方法</td>
<td style="text-align: center"><code>call(scope, arg1,arg2,..)</code></td>
<td style="text-align: center">设置函数体内 this 对象的值，扩充函数运行的作用域</td>
</tr>
<tr>
<td style="text-align: center">方法(ES5)</td>
<td style="text-align: center"><code>bind(scope)</code></td>
<td style="text-align: center">创建一个函数的实例</td>
</tr>
</tbody>
</table>

<pre><code class="language-js">// arguments.callee
function factorial(num) {
    if( num &lt;= 1 ) {
        return 1;
    }else{
        return arguments.callee(num-1); // 解耦，改变函数名时不用都改变
    }
}

// .length
alert(factorial.length); //希望接收参数数量为1
</code></pre>

<blockquote>
<p>利用 <code>apply()</code> 与 <code>call()</code>  可以将对象与方法解耦</p>
</blockquote>

<pre><code class="language-js">// 扩充函数运行作用域
window.color = &quot;red&quot; ; 
var o = { color: &quot;blue&quot;};

function sayColor(){ alert(this.color); }

sayColor();             //red
sayColor.call(this);    //red
sayColor.call(window);  //red
sayColor.call(o);       //blue

var objectSayColor = sayColor.bind(o);
objectSayColor();       //blue
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css 布局系统]]></title>
    <link href="http://blog.kayorl.com/css-layout.html"/>
    <updated>2017-03-04T09:49:29+08:00</updated>
    <id>http://blog.kayorl.com/css-layout.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">grid</a>
</li>
<li>
<a href="#toc_1">flexbox</a>
</li>
<li>
<a href="#toc_2">column</a>
</li>
<li>
<a href="#toc_3">inline-block</a>
</li>
<li>
<a href="#toc_4">float</a>
<ul>
<li>
<a href="#toc_5">overflow 技巧</a>
</li>
<li>
<a href="#toc_6">clearfix 技巧</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h2 id="toc_0">grid</h2>

<pre><code>/*------------------------------*\
    Grid System
\*------------------------------*/


/* reseting the box model */

.row,
.column {
    box-sizing: border-box;
}


/* clearing floats */

.row:before,
.row:after {
    content: &quot;&quot;;
    display: table;
}

.row:after {
    clear: both;
}


/* defining columns, common style
 * float left will cause the element to become display:block 
 */

.column {
    position: relative;
    float: left;
}


/* creating gutters */

.column + .column {
    margin-left: 1.6%;
}


/* calculating column widths , 12columns
 * 去除12列之间的 沟(gutter) 后的单列宽
 * 1 column width = (100 - (margin * (maximum columns - 1)))/ maximum columns
 *                = (100 - (1.6 * ( 12 - 1 ) )) / 12 
 *                = 6.86666666667
 *
 * 多列自动合并中间的 沟宽
 * n column width = (1 column width * column span ) + (margin *  (column span -1) ))                  
 * 2 column width = (6.86666666667 * 2) +  (1.6 * (2 - 1))
 *              
 */


/* 12 columns */

.column-1 {
    width: 6.86666666667%;
}

.column-2 {
    width: 15.3333333333%;
}

.column-3 {
    width: 23.8%;
}

.column-4 {
    width: 32.2666666667%;
}

.column-5 {
    width: 40.7333333333%;
}

.column-6 {
    width: 49.2%;
}

.column-7 {
    width: 57.6666666667%;
}

.column-8 {
    width: 66.1333333333%;
}

.column-9 {
    width: 74.6%;
}

.column-10 {
    width: 83.0666666667%;
}

.column-11 {
    width: 91.5333333333%;
}

.column-12 {
    width: 100%;
}

@media only screen and (max-width: 550px) {
    .column-1,
    .column-2,
    .column-3,
    .column-4,
    .column-5,
    .column-6,
    .column-7,
    .column-8,
    .column-9,
    .column-10,
    .column-11,
    .column-12 {
        width: auto;
        float: none;
    }
    .column + .column {
        margin-left: 0;
    }
}

</code></pre>

<h2 id="toc_1"><a href="http://www.w3cplus.com/css3/flexbox-basics.html">flexbox</a></h2>

<blockquote>
<p>无法实现无缝瀑布流布局</p>
</blockquote>

<p>flex 的容器属性</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>[flex-flow]</td>
<td>[flex-direction],[flex-wrap]</td>
<td>方向与换行</td>
</tr>
<tr>
<td>[flex-direction]</td>
<td>row / row-reverse<br>column / column-reverse</td>
<td>方向</td>
</tr>
<tr>
<td>[flex-wrap]</td>
<td>no-wrap / wrap <br> wrap-reverse</td>
<td>换行</td>
</tr>
<tr>
<td>[align-items]</td>
<td>flex-start/baseline <br> flex-end<br> center <br>stretch</td>
<td>侧轴对齐方式</td>
</tr>
<tr>
<td>[justify-content]</td>
<td>flex-start / flex-end <br>center <br>space-between <br>space-around</td>
<td>伸缩项分布方式</td>
</tr>
<tr>
<td>[align-content]</td>
<td>flex-start / flex-end <br>center<br> space-between<br> space-around <br>stretch</td>
<td>伸缩项对齐方式</td>
</tr>
</tbody>
</table>

<pre><code>.container {
  display: -webkit-flex;
  display: flex;
  flex-flow: row wrap;
}

/* 最大200px，最小100px */
.initial {
  -webkit-flex: initial;
          flex: initial;
  width: 200px;
  min-width: 100px;
}

/*  固定200px */
.none {
  -webkit-flex: none;
          flex: none;
  width: 200px;
}

/* 占据剩余宽度的 1/flex(n) */
.flex1 {
  -webkit-flex: 1;
          flex: 1;
}

/* 占据剩余宽度的 2/flex(n) */
.flex2 {
  -webkit-flex: 2;
          flex: 2;
}
</code></pre>

<h2 id="toc_2">column</h2>

<p>内容多列显示</p>

<pre><code>.three-column {
  padding: 1em;
  -moz-column-count: 3;
  -moz-column-gap: 1em;
  -webkit-column-count: 3;
  -webkit-column-gap: 1em;
  column-count: 3;
  column-gap: 1em;
}
</code></pre>

<h2 id="toc_3"><a href="http://zh.learnlayout.com/inline-block-layout.html">inline-block</a></h2>

<p>可以用 inline-block 来布局，但需要记住<br/>
* <code>vertical-align</code>  会影响 <code>inline-block</code> 元素, 可能会设置为<code>top</code><br/>
* 需要设置每一列的宽度<br/>
* 如果元素之间有空格，列之间会产生空隙</p>

<blockquote>
<p>the default vertical-align value on inline or inline-block element is <u>baseline</u> , which means the element’s baseline will be aligned with its parent’s baseline.</p>
</blockquote>

<p><img src="media/14885921690264/baseline-inline-block.jpg" alt="baseline-inline-block"/></p>

<h2 id="toc_4">float</h2>

<h3 id="toc_5">overflow 技巧</h3>

<p>在包含浮动元素的父容器中设置“overflow”的属性值为“auto”，这样父容器就会有一个高度存在。</p>

<pre><code>.box {
    overflow : auto;
    zoom: 1;    /* 支持 ie 6 */
}
</code></pre>

<ol>
<li>元素想移动到父容器外面会被截断，如 盒子阴影和下拉菜单</li>
<li>不同的浏览器对“overflow”属性解析不一样，在浏览器的显示风格也不一样</li>
</ol>

<h3 id="toc_6">clearfix 技巧</h3>

<p>使用<code>&quot;display : tabel&quot;</code>创建一个匿名的<code>&quot;tabel-cell&quot;</code>元素<br/>
在父元素上使用 <code>&quot;:before&quot;</code>伪类，使得父容器顶部创建了一个隐藏元素，防止子元素的顶部外边距塌陷。<br/>
在父元素上使用<code>&quot;:after&quot;</code>伪类,可以在父容器底部创建隐藏元素，防止子元素的底部外边距塌陷与清除元素浮动。</p>

<pre><code class="language-css">/*-- our cleafix hack -- */ 
.row:before, 
.row:after {
    content: &quot;&quot; ;
    display: table ;
    clear: both ;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 数据类型 之 性格]]></title>
    <link href="http://blog.kayorl.com/datatype.html"/>
    <updated>2017-02-16T20:05:35+08:00</updated>
    <id>http://blog.kayorl.com/datatype.html</id>
    <content type="html"><![CDATA[
<p>学会数据类型，防止自己挖坑自己跳 (￣o￣) . z Z</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Undefined 类型，只有一个值 undefined</h2>

<ol>
<li>声明，但不赋值变量，默认值为 undefined</li>
<li>不声明，直接操作变量， <u>不会有默认值</u></li>
<li>奇怪的是 typeof 操作符都返回 undefined</li>
</ol>

<pre><code>var msg;
alert (msg == undefiend);   // true
alert (age == undefined);   // ERROR!

alert (typeof undefined);   // undefined
alert (typeof undefined);   // undefined
</code></pre>

<h2 id="toc_1">Null 类型, 只有一个值 null</h2>

<ol>
<li>null 表示一个空对象指针 </li>
<li>用 typeof 检测时会返回 <u>object</u>.</li>
<li>如果变量以后要保存对象，那么初始化为 null 会更好</li>
</ol>

<pre><code>alert (typeof null);    // object

if ( car ! = null ) {
    //对 car 对象进行操作
}
</code></pre>

<h2 id="toc_2">Number 类型</h2>

<ol>
<li>浮点运算会产生误差，不要测定特定的浮点数值</li>
<li>无穷值用 <code>isFinite()</code> 检查</li>
<li>范围数值的操作数未返回数值，用 NaN 表示，用 <code>isNaN()</code> 检查</li>
</ol>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">“hello&quot;</th>
<th style="text-align: center">undefined</th>
<th style="text-align: center">null</th>
<th style="text-align: center">“”</th>
<th style="text-align: center">true</th>
<th style="text-align: center">“000011&quot;</th>
<th style="text-align: center">22.5</th>
<th style="text-align: center">22.5.5</th>
<th style="text-align: center">1234hdhd</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Number()</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">0</td>
<td style="text-align: center">0</td>
<td style="text-align: center">1</td>
<td style="text-align: center">11</td>
<td style="text-align: center">22.5</td>
<td style="text-align: center">ERROR</td>
<td style="text-align: center">ERROR</td>
</tr>
<tr>
<td style="text-align: center">parseInt(obj,base)</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">11</td>
<td style="text-align: center">22</td>
<td style="text-align: center">22</td>
<td style="text-align: center">1234</td>
</tr>
<tr>
<td style="text-align: center">parseFloat()</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">NaN</td>
<td style="text-align: center">11</td>
<td style="text-align: center">22.5</td>
<td style="text-align: center">22.5</td>
<td style="text-align: center">1234</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">String 类型，值不变</h2>

<ol>
<li>确定值不为 null 或 undefined 时直接用 <code>toString()</code> 方法</li>
<li>null 与 undefined 无 <code>toString()</code> 方法</li>
<li>调用 <code>String()</code> 方法,可以将任意值转换为字符串 (个人觉得为了安全还是不要的好)</li>
</ol>

<pre><code class="language-js">
function String(obj){
    if(typeof obj.toString() === &quot;function&quot;) {
        return obj.toString();      // 方法
    }
    if(obj === null) {
        return &quot;null&quot;;
    }
    if(typeof obj === undefined) {
        return &quot;undefined&quot;;
    }
}
</code></pre>

<h2 id="toc_4">Object 类型</h2>

<table>
<thead>
<tr>
<th style="text-align: left">方法</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">constructor</td>
<td style="text-align: left">构造函数</td>
</tr>
<tr>
<td style="text-align: left">hasOwnProperty(propertyName)</td>
<td style="text-align: left">检查属性是否存在当前对象实例中</td>
</tr>
<tr>
<td style="text-align: left">isPrototypeOf(object)</td>
<td style="text-align: left">检查传入对象是否为当前对象的原型</td>
</tr>
<tr>
<td style="text-align: left">toLocalString()</td>
<td style="text-align: left">返还执行环境地区的字符串</td>
</tr>
<tr>
<td style="text-align: left">toString()</td>
<td style="text-align: left">返回字符串表示</td>
</tr>
<tr>
<td style="text-align: left">valueOf()</td>
<td style="text-align: left">返回字符串、数值或布尔值表示</td>
</tr>
</tbody>
</table>

<blockquote>
<p>内置函数和操作符的操作流程</p>
</blockquote>

<pre><code class="language-js">if( !obj.valueOf().func() ){
    return ...;
}else{
    if( ! obj.toString().func() ) {
        return ...;
    }else {
        return ...;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[html 文档的解析，及 script 标签位置的选择]]></title>
    <link href="http://blog.kayorl.com/html-decode.html"/>
    <updated>2017-02-16T20:05:35+08:00</updated>
    <id>http://blog.kayorl.com/html-decode.html</id>
    <content type="html"><![CDATA[
<p>读 《JavaScript高级程序设计》时，对 html 的标签解析感到模糊，参考了博文，根据理解画了以下的解析流程图，有误请指教哈~</p>

<span id="more"></span><!-- more -->

<p><img src="http://olh3adg9x.bkt.clouddn.com/decode_html.png" alt="decode_htm"/></p>

<p>浏览器对非延迟执行的脚本都是立即执行的，导致浏览器呈现内容的速度变慢（即页面空白的时间过久），造成不好的用户体验。</p>

<blockquote>
<p>因此把所有脚本放到<code>&lt;body&gt;</code>元素的最后面</p>
</blockquote>

<p>有人说，全用 defer 脚本不就好了吗？  <strong><em>人无完人，defer 也有限制</em></strong></p>

<blockquote>
<p>延迟脚本直到 <code>&lt;/html&gt;</code> 标签解析完后加载;<br/>
<u>只有一个</u> 延迟脚本能按顺序执行;<br/>
只适用于外部脚本文件</p>
</blockquote>

<p>async 异步呢？其存在的目的是 <strong><em>不让页面等待两个脚本下载和执行</em></strong></p>

<blockquote>
<p>不保证先后顺序<br/>
只适用于外部脚本文件</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解 DOCTYPE 声明的意义]]></title>
    <link href="http://blog.kayorl.com/doctype.html"/>
    <updated>2017-03-08T10:01:30+08:00</updated>
    <id>http://blog.kayorl.com/doctype.html</id>
    <content type="html"><![CDATA[
<p>每次看到 html 文档时，已经习惯了头部有个 <code>&lt;!DOCTYPE html&gt;</code>，印象也有些模糊，趁着学习 css ，赶紧整理一下</p>

<span id="more"></span><!-- more -->

<p>文档类型中会出现的元素限制。</p>

<h2 id="toc_0">DOCTYPE 声明对页面进行有效性验证</h2>

<blockquote>
<p>DTD (Document Type Definition, 文档定义类型)定义 XML 或 HTML 的特定版本允许有什么，不允许有什么。</p>

<p>SGML (Standard Generalized Markup language, 标准通用标记语言) 是一种定义电子文档结构和描述其内容的国际标准语言</p>
</blockquote>

<p>利用 <a href="http://validator.w3.org/">w3c 认证器</a>, 有助于找到代码中的 bug 。<br/>
它是通过与标准HTML规则进行比较的方式，分析HTML文档、标记出错误和非标准代码的处理过程。<br/>
Web页面使用HTML进行渲染，而HTML本身采用了HTML规范作为其规则和标准。</p>

<h2 id="toc_1">DOCTYPE 声明让浏览器有不同的呈现形式</h2>

<blockquote>
<p>标准模式(standard mode)：根据规范的一种呈现形式<br/>
混杂模式(quirk mode)：模拟老式浏览器的一种呈现形式，盒模型（border-box）</p>
</blockquote>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">DTD</th>
<th style="text-align: center">standard</th>
<th style="text-align: center">quirk</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">NO</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center">yes</td>
</tr>
<tr>
<td style="text-align: center"> HTML4.01</td>
<td style="text-align: center">strict</td>
<td style="text-align: center">yes</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">Transitional &amp;&amp; url</td>
<td style="text-align: center">yes</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center">Transitional &amp;&amp; NO url</td>
<td style="text-align: center"></td>
<td style="text-align: center">yes</td>
</tr>
<tr>
<td style="text-align: center">HTML5</td>
<td style="text-align: center"> 不基于 SGML，所以不需要引用 DTD</td>
<td style="text-align: center">yes</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

<h2 id="toc_2">混杂模式特点</h2>

<ol>
<li>盒模型的高宽包含内边距padding和边框border</li>
<li>可以设置行内元素的高宽</li>
<li>可设置百分比的高度</li>
<li>用<code>margin:0 auto</code>设置水平居中在IE下会失效</li>
<li>设置图片的padding会失效</li>
<li>Table中的字体属性不能继承上层的设置</li>
<li><code>white-space: pre</code>会失效</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 语句]]></title>
    <link href="http://blog.kayorl.com/mysql-.html"/>
    <updated>2017-02-16T19:29:42+08:00</updated>
    <id>http://blog.kayorl.com/mysql-.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">存储创建时间和最后修改时间</h2>

<pre><code class="language-sql">CREATE TABLE t1
(
    tb_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ts_modifiled TIMESTAMP DEFAULT CURRNET_TIMESTAMP
                            ON UPDATE CURRENT_TIMESTAMP,
    ...
):
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL5.7 从相见到👋]]></title>
    <link href="http://blog.kayorl.com/mysql.html"/>
    <updated>2017-02-16T16:31:58+08:00</updated>
    <id>http://blog.kayorl.com/mysql.html</id>
    <content type="html"><![CDATA[
<p>我的意中人是个盖世英雄<br/>
有一天他会踩着七色云彩来娶我<br/>
我猜中了前头,<br/>
可是我猜不着这结局</p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">安装</a>
</li>
<li>
<a href="#toc_1">建立与 MySQL 服务器的连接</a>
</li>
<li>
<a href="#toc_2">导入 .sql 文件</a>
</li>
<li>
<a href="#toc_3">修改时区</a>
</li>
<li>
<a href="#toc_4">备份</a>
</li>
<li>
<a href="#toc_5">卸载</a>
</li>
</ul>


<h2 id="toc_0">安装</h2>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-16-04">DO教程</a></p>

<pre><code># 安装 
$ sudo apt-get update
$ sudo apt-get install mysql-server

# 修改数据库的安全配置，如禁用远程 root 用户
$ sudo mysql_secure_installation

## 测试数据库状态
$ systemctl status mysql.service
</code></pre>

<h2 id="toc_1">建立与 MySQL 服务器的连接</h2>

<p>为连接到 MySQL 服务器,在命令行中调用 mysql 程序</p>

<pre><code>$ mysql -h host_name -p -u user_name -D database_name
</code></pre>

<ul>
<li><code>mysql</code> 是必须的, 其他可选</li>
<li>-h  host_name　　　主机地址,默认为本地</li>
<li>-u  user_name　　　MySQL 用户名</li>
<li>-p　　　　　　　　回显 Enter password: ，如果相应用户名有密码而没加此项，会显示<code>拒绝访问</code></li>
<li>-D  database_name 选择操作(默认)的数据库<br/></li>
</ul>

<h2 id="toc_2">导入 .sql 文件</h2>

<p>可以将编写好的数据库语句写入到文件名后缀为 <code>.sql</code> 的文件中,并记住其路径,最简单的方法是在命令行中进入到.sql 文件所在的目录,然后在<code>命令行</code>执行以下命令(省略了主机名,用户,密码等参数)</p>

<pre><code>$ mysql sampdb &lt; create_member.sql
</code></pre>

<p>如果已经进入 mysql 程序界面,则执行</p>

<pre><code>mysql&gt; source create_member.sql;
</code></pre>

<h2 id="toc_3">修改时区</h2>

<pre><code># /etc/my.cnf

[mysqld]
...
default-time-zone = &#39;+8:00&#39;

$ systemctl restart mysql
</code></pre>

<h2 id="toc_4">备份</h2>

<pre><code>$ mysqldump -u -p -D exampleDB &gt;my.sql
</code></pre>

<h2 id="toc_5">卸载</h2>

<p>purge,翻译过来是净化的意思</p>

<pre><code>sudo apt-get remove --purge mysql*
sudo apt-get autoremove
sudo apt-get autoclean
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Sequelize(6) sequelize-cli，出门必备良品]]></title>
    <link href="http://blog.kayorl.com/sequelize-cli.html"/>
    <updated>2017-02-16T20:10:13+08:00</updated>
    <id>http://blog.kayorl.com/sequelize-cli.html</id>
    <content type="html"><![CDATA[
<p>让数据库转移到那些年的状态<br/>
通过<strong>迁移文件</strong>存储数据库不同时期的状态，每个迁移文件描述了对数据库的操作</p>

<span id="more"></span><!-- more -->

<p><strong>CLI</strong>:  <code>command-line interface</code> , 命令行界面</p>

<h2 id="toc_0">全局安装</h2>

<pre><code>$ npm install -g sequelize-cli
</code></pre>

<h3 id="toc_1">使用</h3>

<pre><code>$ sequelize
</code></pre>

<p>迁移文件一般长这样</p>

<blockquote>
<p>queryInterface : 修改数据库</p>

<p>Sequelize : 提供多种类型</p>
</blockquote>

<pre><code class="language-js">module.exports = {
  up: function(queryInterface, Sequelize) {
    // logic for transforming into the new state
  },
 
  down: function(queryInterface, Sequelize) {
    // logic for reverting the changes
  }
}
</code></pre>

<p>queryInterface有一下几个函数（常用）：</p>

<ul>
<li>createTable(tableName, attributes, options)</li>
<li>addIndex(tableName, attributes, options)</li>
<li>dropTable(tableName, options)</li>
</ul>

<h2 id="toc_2">createTable(tableName, attributes, options)</h2>

<pre><code>queryInterface.createTable(
  &#39;nameOfTheNewTable&#39;,
  {
    id: {
      type: Sequelize.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    createdAt: {
      type: Sequelize.DATE
    },
    updatedAt: {
      type: Sequelize.DATE
    },
    attr1: Sequelize.STRING,
    attr2: Sequelize.INTEGER,
    attr3: {
      type: Sequelize.BOOLEAN,
      defaultValue: false,
      allowNull: false
    },
    //foreign key usage
    attr4: {
        type: Sequelize.INTEGER,
        references: {
            model: &#39;another_table_name&#39;,
            key: &#39;id&#39;
        },
        onUpdate: &#39;cascade&#39;,
        onDelete: &#39;cascade&#39;
    }
  },
  {
    engine: &#39;MYISAM&#39;,                     // default: &#39;InnoDB&#39;
    charset: &#39;utf8&#39;,                    // default: null
    schema: &#39;public&#39;                      // default: public, PostgreSQL only.
  }
)
</code></pre>

<h2 id="toc_3">addIndex(tableName, attributes, options)</h2>

<pre><code class="language-js">// This example will create the index person_firstname_lastname
queryInterface.addIndex(&#39;Person&#39;, [&#39;firstname&#39;, &#39;lastname&#39;])



// This example will create a unique index with the name SuperDuperIndex using the optional &#39;options&#39; field.
// Possible options:
// - indicesType: UNIQUE|FULLTEXT|SPATIAL
// - indexName: The name of the index. Default is __
// - parser: For FULLTEXT columns set your parser
// - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect
// - logging: A function that receives the sql query, e.g. console.log
queryInterface.addIndex(
  &#39;Person&#39;,
  [&#39;firstname&#39;, &#39;lastname&#39;],
  {
    indexName: &#39;SuperDuperIndex&#39;,
    indicesType: &#39;UNIQUE&#39;
  }
)
</code></pre>

<h2 id="toc_4">dropTable(tableName, options)</h2>

<pre><code>queryInterface.dropTable(&#39;nameOfTheExistingTable&#39;)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Sequelize(5) 几对几]]></title>
    <link href="http://blog.kayorl.com/sequelize-?-?.html"/>
    <updated>2017-02-16T15:50:14+08:00</updated>
    <id>http://blog.kayorl.com/sequelize-?-?.html</id>
    <content type="html"><![CDATA[
<p>一对一，一对多，多对多</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一对一</h2>

<h3 id="toc_1">hasOne</h3>

<h3 id="toc_2">belongsTo</h3>

<blockquote>
<p>区别: <code>联系键</code> 添加的地方不一样</p>
</blockquote>

<pre><code class="language-js">var Player = this.sequelize.define(&#39;player&#39;, {/* attributes */}), 
    Coach  = this.sequelize.define(&#39;coach&#39;, {/* attributes */}), 
    Team  = this.sequelize.define(&#39;team&#39;, {/* attributes */}),
    Game =  this.sequelize.define(&#39;game&#39;, {/* attributes */});


Player.belongsTo(Team);     // 添加 teamId 到 Player
Coach.hasOne(Team);         //添加 coachId 到 Team
</code></pre>

<p>通过 hasOne 方法添加的模型</p>

<blockquote>
<p>对新添加模型的 setter 和 getter 会自动以模型名为后缀</p>

<p>此外，也会以  <code>模型名+id</code> 的形式生成外码</p>
</blockquote>

<p>可以通过以下代码修改</p>

<pre><code class="language-js">// Person#getPerson, Person#setPerson

Person.hasOne(Person);


// 增加方法Person#getFather,Person#setFather
// 修改外码为dadId

Person.hasOne(Person, {as: &#39;Father&#39;, foreignKey: &#39;dad_id&#39;})
</code></pre>

<h2 id="toc_3">一对多</h2>

<pre><code class="language-js">var User = sequelize.define(&#39;user&#39;, {/* ... */})
var Project = sequelize.define(&#39;project&#39;, {/* ... */})
 
// Project#getWorkers , Project#setWorkers

Project.hasMany(User, {as: &#39;Workers&#39;})
</code></pre>

<h2 id="toc_4">多对多</h2>

<blockquote>
<p>使用belongToMany,为两个多对多的模型建立联系</p>

<p>通过创建一个中间模型<code>(联系集)</code>实现</p>
</blockquote>

<pre><code class="language-js">User = sequelize.define(&#39;user&#39;, {})
Project = sequelize.define(&#39;project&#39;, {})
UserProjects = sequelize.define(&#39;userProjects&#39;, {
    id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    status: DataTypes.STRING
})
 
User.belongsToMany(Project, {  as: &#39;Tasks&#39;, through: UserProjects, foreignKey: &#39;userId&#39; })
Project.belongsToMany(User, {  as: &#39;Workers&#39;,through: UserProjects ,foreignKey: &#39;projectId&#39;})


// 添加一个 project, 并且,设置其状态为 started

user.addProject(project, { status: &#39;started&#39; })


// 使用 through 可以选择特定属性

User.findAll({
  include: [{
    model: Project,
    through: {
      attributes: [&#39;createdAt&#39;, &#39;startedAt&#39;, &#39;finishedAt&#39;],
      where: {completed: true}
    }
  }]
});
</code></pre>

<blockquote>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Sequelize(4) 范围]]></title>
    <link href="http://blog.kayorl.com/sequelize-range.html"/>
    <updated>2017-02-16T15:50:14+08:00</updated>
    <id>http://blog.kayorl.com/sequelize-range.html</id>
    <content type="html"><![CDATA[
<p>范围（<code>scope</code>）: 定义好范围,在后续的操作中可以减少选择条件的重复，比如，只在<strong>未删除用户</strong>列表中进行操作。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">范围是对模型的一种分类</h2>

<pre><code class="language-js">// 修改默认所有操作的范围 default Scope
var Project = sequelize.define( &#39;project&#39;, {
    // Attributes
}, {
    defaultScope: {
        where: {
            active: true
        }
    },
    scopes: {
        deleted: {
            where: {
                deleted: true
            }
        },
        activeUsers: {
            include: [
                { model: User, where: { active: true } }
      ]
        }
    }
} );



// 移除默认范围，设置为 deleted 范围
Project.scope( &#39;deleted&#39; ).findAll();

// 与上面等价
var DeletedProjects = Project.scope( &#39;deleted&#39; );
DeletedProjects.findAll();

var Post = sequelize.define( &#39;post&#39;, attributes, {
    defaultScope: {
        where: {
            active: true
        }
    },
    scopes: {
        deleted: {
            where: {
                deleted: true
            }
        }
    }
} );
</code></pre>

<h2 id="toc_1">例子</h2>

<pre><code class="language-js">User.hasMany( Post ); // regular getPosts association
User.hasMany( Post.scope( &#39;deleted&#39; ), { as: &#39;deletedPosts&#39; } );
</code></pre>

]]></content>
  </entry>
  
</feed>
